#include "JSONFox.h"

* load all classes
Set Procedure To "src\JSONClass" 		Additive
Set Procedure To "src\Tokenizer" 		Additive
Set Procedure To "src\Parser" 			Additive
Set Procedure To "src\JSONUtils" 		Additive
Set Procedure To "src\ArrayToCursor" 	Additive
Set Procedure To "src\CursorToArray" 	Additive
Set Procedure To "src\JSONStringify" 	Additive
Set Procedure To "src\ObjectToJSON" 	Additive
Set Procedure To "src\JSONToRTF" 		Additive
Set Procedure To "src\StructureToJSON" 	Additive

* Include Toml files
Set Procedure To "src\toml_lexer" 		Additive
Set Procedure To "src\toml_parser" 		Additive
Set Procedure To "src\toml_class" 		Additive

* All tokens generated by the lexer ***(DO NOT MANIPULATE)***
If Type('_SCREEN.tokens') != 'U'
	=Removeproperty(_Screen, 'tokens')
Endif
=AddProperty(_Screen, 'tokens(1)', 0)

* current token position ***(DO NOT MANIPULATE)***
If Type('_SCREEN.curTokenPos') != 'U'
	=Removeproperty(_Screen, 'curTokenPos')
Endif
=AddProperty(_Screen, 'curTokenPos', 1)

* Lexer grammar specifications  ***(DO NOT MANIPULATE)***
If Type('_SCREEN.Spec') != 'U'
	=Removeproperty(_Screen, 'Spec')
Endif
=AddProperty(_Screen, 'Spec(1)', 0)

* Tokenizer object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.Tokenizer') != 'U'
	=Removeproperty(_Screen, 'Tokenizer')
Endif
=AddProperty(_Screen, 'Tokenizer', Createobject("Tokenizer"))

* Parser object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.Parser') != 'U'
	=Removeproperty(_Screen, 'Parser')
Endif
=AddProperty(_Screen, 'Parser', Createobject("Parser"))

* oPeek object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.oPeek') != 'U'
	=Removeproperty(_Screen, 'oPeek')
Endif
=AddProperty(_Screen, 'oPeek', .Null.)

* oPrevious object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.oPrevious') != 'U'
	=Removeproperty(_Screen, 'oPrevious')
Endif
=AddProperty(_Screen, 'oPrevious', .Null.)

* JsonUtils object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.JsonUtils') != 'U'
	=Removeproperty(_Screen, 'JsonUtils')
Endif
=AddProperty(_Screen, 'JsonUtils', Createobject("JSONUtils"))

* Global Regular Expression object  (YOU MAY MANIPULATE IT).
If Type('_SCREEN.oRegEx') != 'U'
	=Removeproperty(_Screen, 'oRegEx')
Endif
=AddProperty(_Screen, 'oRegEx', Createobject("VBScript.RegExp"))
_Screen.oRegEx.Global = .T.

* ArrayToCursor object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.ArrayToCursor') != 'U'
	=Removeproperty(_Screen, 'ArrayToCursor')
Endif
=AddProperty(_Screen, 'ArrayToCursor', Createobject("ArrayToCursor"))

* CursorToArray object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.CursorToArray') != 'U'
	=Removeproperty(_Screen, 'CursorToArray')
Endif
=AddProperty(_Screen, 'CursorToArray', Createobject("CursorToArray"))

* JSONStringify object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.JSONStringify') != 'U'
	=Removeproperty(_Screen, 'JSONStringify')
Endif
=AddProperty(_Screen, 'JSONStringify', Createobject("JSONStringify"))

* ObjToJson object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.ObjectToJson') != 'U'
	=Removeproperty(_Screen, 'ObjectToJson')
Endif
=AddProperty(_Screen, 'ObjectToJson', Createobject("ObjectToJson"))

* JSONToRTF object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.JSONToRTF') != 'U'
	=Removeproperty(_Screen, 'JSONToRTF')
EndIf
=AddProperty(_Screen, 'JSONToRTF', Createobject("JSONToRTF"))

* StructureToJSON object ***(DO NOT MANIPULATE)***
If Type('_SCREEN.StructureToJSON') != 'U'
	=Removeproperty(_Screen, 'StructureToJSON')
Endif
=AddProperty(_Screen, 'StructureToJSON', Createobject("StructureToJSON"))

* Create all grammars for the lexer.
=CreateLexerSpecs()

* Main JSON class handler.
If Type("_Screen.Json") != "U"
	=Removeproperty(_Screen, 'Json')
Endif
=AddProperty(_Screen, "Json", Createobject("JsonClass"))

* Main TOML class handler
If Type("_Screen.Toml") != "U"
	=Removeproperty(_Screen, 'Toml')
Endif
=AddProperty(_Screen, "Toml", Createobject("TomlClass"))

Return

* CreateLexerSpecs -> Create specification pattern array.
Function CreateLexerSpecs
	* Whitespace ignored.
	i = 1
	FillSpec(i, "^\s+", T_NONE) && 0 => NULL

	* '{'
	i = i + 1
	FillSpec(i, '^{', T_LBRACE)

	* STRING -> "string" with no spaces in between. (for keys)
	i = i + 1
	FillSpec(i, '^"[^"^ ]*"', T_STRING)

	* ':'
	i = i + 1
	FillSpec(i, '^:', T_COLON)

	* STRING -> "string" with escape special characters.
	i = i + 1
	FillSpec(i, '^"(?:[^"\\]|\\.)*"', T_STRING)

	* '['
	i = i + 1
	FillSpec(i, '^\[', T_LBRACKET)

	* BOOLEAN
	i = i + 1
	FillSpec(i, '^true', T_BOOLEAN)

	* BOOLEAN
	i = i + 1
	FillSpec(i, '^false', T_BOOLEAN)

	* 'null'
	i = i + 1
	FillSpec(i, '^null', T_NULL)

	* NUMBER
	i = i + 1
	FillSpec(i, '^[-]?[\d\.]+', T_NUMBER)

	* ','
	i = i + 1
	FillSpec(i, '^,', T_COMMA)

	* ']'
	i = i + 1
	FillSpec(i, '^\]', T_RBRACKET)

	* '}'
	i = i + 1
	FillSpec(i, '^}', T_RBRACE)

	Return
Endfunc

* Fill pattern
Function FillSpec(tnSize, tcPattern, tnType)
	Dimension _Screen.Spec(tnSize, 2)
	_Screen.Spec[tnSize, 1] = tcPattern
	_Screen.Spec[tnSize, 2] = tnType

	Return
Endfunc